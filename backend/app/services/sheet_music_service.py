"""
Sheet music service for generating sheet music from transcribed notes
"""

import os
import subprocess
import tempfile

def generate_sheet_music(notes, tempo, output_dir, title="Transcribed Music", 
                        composer="Music Transcription App", difficulty="beginner", 
                        include_chords=True):
    """
    Generate sheet music from transcribed notes using LilyPond
    
    Args:
        notes (dict): Dictionary with right_hand and left_hand notes
        tempo (float): Tempo in BPM
        output_dir (str): Directory to save output files
        title (str): Title of the piece
        composer (str): Composer name
        difficulty (str): Difficulty level ('beginner', 'intermediate', 'advanced')
        include_chords (bool): Whether to include chord symbols
        
    Returns:
        tuple: (lily_file, pdf_file) paths
    """
    # Create LilyPond file content
    lily_content = _create_lilypond_content(
        notes, tempo, title, composer, difficulty, include_chords
    )
    
    # Write LilyPond file
    lily_file = os.path.join(output_dir, "sheet_music.ly")
    with open(lily_file, 'w') as f:
        f.write(lily_content)
    
    # Generate PDF using LilyPond
    try:
        subprocess.run(
            ['lilypond', '-o', os.path.join(output_dir, "sheet_music"), lily_file],
            check=True,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE
        )
        
        pdf_file = os.path.join(output_dir, "sheet_music.pdf")
        
        if not os.path.exists(pdf_file):
            raise Exception("Failed to generate PDF file")
        
        return lily_file, pdf_file
    
    except subprocess.CalledProcessError as e:
        raise Exception(f"LilyPond error: {e.stderr.decode('utf-8')}")
    
    except Exception as e:
        raise Exception(f"Failed to generate sheet music: {str(e)}")

def create_preview_image(pdf_file, output_dir):
    """
    Create preview image from PDF file
    
    Args:
        pdf_file (str): Path to PDF file
        output_dir (str): Directory to save output files
        
    Returns:
        str: Path to preview image
    """
    # Generate preview image using ImageMagick
    preview_file = os.path.join(output_dir, "sheet_music_preview.png")
    
    try:
        subprocess.run(
            ['convert', '-density', '150', '-quality', '90', f'{pdf_file}[0]', preview_file],
            check=True,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE
        )
        
        if not os.path.exists(preview_file):
            raise Exception("Failed to generate preview image")
        
        return preview_file
    
    except subprocess.CalledProcessError as e:
        raise Exception(f"ImageMagick error: {e.stderr.decode('utf-8')}")
    
    except Exception as e:
        raise Exception(f"Failed to create preview image: {str(e)}")

def _create_lilypond_content(notes, tempo, title, composer, difficulty, include_chords):
    """
    Create LilyPond file content from transcribed notes
    
    Args:
        notes (dict): Dictionary with right_hand and left_hand notes
        tempo (float): Tempo in BPM
        title (str): Title of the piece
        composer (str): Composer name
        difficulty (str): Difficulty level
        include_chords (bool): Whether to include chord symbols
        
    Returns:
        str: LilyPond file content
    """
    # LilyPond version
    lily_content = '\\version "2.20.0"\n\n'
    
    # Header
    lily_content += '\\header {\n'
    lily_content += f'  title = "{title}"\n'
    lily_content += f'  composer = "{composer}"\n'
    lily_content += '  tagline = "Generated by Music Transcription Web App"\n'
    lily_content += '}\n\n'
    
    # Global settings
    lily_content += 'global = {\n'
    lily_content += '  \\time 4/4\n'
    lily_content += f'  \\tempo 4 = {int(tempo)}\n'
    lily_content += '  \\key c \\major\n'
    lily_content += '}\n\n'
    
    # Right hand (melody)
    lily_content += 'right = \\relative c\' {\n'
    lily_content += '  \\global\n'
    lily_content += '  \\clef treble\n'
    
    # Convert right hand notes to LilyPond notation
    if 'right_hand' in notes and notes['right_hand']:
        lily_content += _notes_to_lilypond(notes['right_hand'])
    else:
        # Default empty measure
        lily_content += '  r1 |\n'
    
    lily_content += '}\n\n'
    
    # Left hand (accompaniment)
    lily_content += 'left = \\relative c {\n'
    lily_content += '  \\global\n'
    lily_content += '  \\clef bass\n'
    
    # Convert left hand notes to LilyPond notation
    if 'left_hand' in notes and notes['left_hand']:
        lily_content += _notes_to_lilypond(notes['left_hand'])
    else:
        # Default empty measure
        lily_content += '  r1 |\n'
    
    lily_content += '}\n\n'
    
    # Score
    lily_content += '\\score {\n'
    lily_content += '  \\new PianoStaff \\with {\n'
    lily_content += '    instrumentName = "Piano"\n'
    lily_content += '  } <<\n'
    lily_content += '    \\new Staff = "right" \\right\n'
    lily_content += '    \\new Staff = "left" \\left\n'
    lily_content += '  >>\n'
    lily_content += '  \\layout { }\n'
    lily_content += '  \\midi { }\n'
    lily_content += '}\n'
    
    return lily_content

def _notes_to_lilypond(notes):
    """
    Convert note events to LilyPond notation
    
    Args:
        notes (list): List of note events
        
    Returns:
        str: LilyPond notation
    """
    # Sort notes by start time
    sorted_notes = sorted(notes, key=lambda x: x['start_time'])
    
    # Group notes by measure
    measures = []
    current_measure = []
    current_time = 0
    measure_duration = 4  # 4 beats per measure in 4/4 time
    
    for note in sorted_notes:
        # Check if note belongs to next measure
        if note['start_time'] >= current_time + measure_duration:
            # Complete current measure
            if current_measure:
                measures.append(current_measure)
            
            # Skip empty measures
            empty_measures = int((note['start_time'] - current_time) / measure_duration)
            for _ in range(empty_measures - 1):
                measures.append([])
            
            # Start new measure
            current_measure = [note]
            current_time = int(note['start_time'] / measure_duration) * measure_duration
        else:
            # Add to current measure
            current_measure.append(note)
    
    # Add final measure
    if current_measure:
        measures.append(current_measure)
    
    # Convert measures to LilyPond notation
    lily_notes = ""
    
    for i, measure in enumerate(measures):
        if not measure:
            # Empty measure
            lily_notes += "  r1 |"
        else:
            # Convert notes in measure
            lily_notes += "  "
            
            # Sort notes by start time
            measure.sort(key=lambda x: x['start_time'])
            
            # Group notes by start time (chords)
            note_groups = {}
            for note in measure:
                # Round to nearest 16th note
                start_time = round(note['start_time'] * 4) / 4
                if start_time not in note_groups:
                    note_groups[start_time] = []
                note_groups[start_time].append(note)
            
            # Convert note groups to LilyPond notation
            for start_time, group in sorted(note_groups.items()):
                # Determine duration
                if len(group) > 0:
                    duration = group[0]['duration']
                    # Quantize to common note durations (whole, half, quarter, eighth, 16th)
                    if duration >= 3.5:
                        lily_duration = "1"  # Whole note
                    elif duration >= 1.5:
                        lily_duration = "2"  # Half note
                    elif duration >= 0.75:
                        lily_duration = "4"  # Quarter note
                    elif duration >= 0.375:
                        lily_duration = "8"  # Eighth note
                    else:
                        lily_duration = "16"  # 16th note
                else:
                    lily_duration = "4"  # Default to quarter note
                
                # Convert pitches to LilyPond notation
                if len(group) == 1:
                    # Single note
                    note = group[0]
                    pitch = _midi_to_lilypond(note['pitch'])
                    lily_notes += f"{pitch}{lily_duration} "
                elif len(group) > 1:
                    # Chord
                    pitches = [_midi_to_lilypond(note['pitch']) for note in group]
                    lily_notes += f"<{' '.join(pitches)}>{lily_duration} "
            
            lily_notes += "|"
        
        # Add line break every 4 measures
        if (i + 1) % 4 == 0:
            lily_notes += "\n  "
        else:
            lily_notes += " "
    
    lily_notes += "\n"
    return lily_notes

def _midi_to_lilypond(midi_pitch):
    """
    Convert MIDI pitch to LilyPond notation
    
    Args:
        midi_pitch (int): MIDI pitch number
        
    Returns:
        str: LilyPond pitch notation
    """
    # MIDI note 60 is middle C (c')
    note_names = ['c', 'cis', 'd', 'dis', 'e', 'f', 'fis', 'g', 'gis', 'a', 'ais', 'b']
    
    # Get note name and octave
    note_name = note_names[midi_pitch % 12]
    octave = midi_pitch // 12 - 1
    
    # Convert to LilyPond notation
    if octave < 3:
        # Add commas for lower octaves
        return note_name + ',' * (3 - octave)
    elif octave > 3:
        # Add apostrophes for higher octaves
        return note_name + '\'' * (octave - 3)
    else:
        # Middle octave
        return note_name
